import { createAppKit } from '@reown/appkit'
import { base, baseSepolia } from '@reown/appkit/networks'
import { WagmiAdapter } from '@reown/appkit-adapter-wagmi'
import { privateKeyToAccount } from 'viem/accounts'
import { toHex, getAddress as checksumAddress } from 'viem'
import { wrapFetchWithPayment } from '@x402/fetch'
import { registerExactEvmScheme } from '@x402/evm/exact/client'
import { x402Client } from '@x402/core/client'

// ============================================
// PRODUCTION MODE - Real wallet connections required
// For testing on testnet, set VITE_TEST_MODE=true in .env
// ============================================
const TEST_MODE = import.meta.env.VITE_TEST_MODE === 'true'
const TEST_PRIVATE_KEY = import.meta.env.VITE_TEST_PRIVATE_KEY || ''

// Test account (derived from private key) - only for testnet testing
const testAccount = TEST_MODE && TEST_PRIVATE_KEY ? privateKeyToAccount(TEST_PRIVATE_KEY) : null

// WalletConnect Project ID - Set VITE_WALLETCONNECT_PROJECT_ID in .env
const projectId = import.meta.env.VITE_WALLETCONNECT_PROJECT_ID

if (!TEST_MODE && (!projectId || projectId === 'undefined')) {
  console.error('VITE_WALLETCONNECT_PROJECT_ID is not set. Get one at https://cloud.reown.com')
}

// Support both Base mainnet and Sepolia testnet
const networks = [base, baseSepolia]

// Create Wagmi adapter
const wagmiAdapter = new WagmiAdapter({
  projectId,
  networks
})

// Create AppKit modal
const modal = createAppKit({
  adapters: [wagmiAdapter],
  networks,
  projectId,
  metadata: {
    name: 'Cartograph',
    description: 'Bespoke City Map Posters',
    url: window.location.origin,
    icons: [window.location.origin + '/static/img/logo.png']
  },
  features: {
    analytics: false
  },
  themeMode: 'dark',
  themeVariables: {
    '--w3m-accent': '#c9a87c',
    '--w3m-color-mix': '#0a0a0a',
    '--w3m-color-mix-strength': 40,
    '--w3m-border-radius-master': '2px'
  }
})

/**
 * Get the current connected wallet address
 * @returns {string|null} The connected address or null
 */
export function getAddress() {
  if (TEST_MODE && testAccount) {
    return testAccount.address
  }
  return modal.getAddress()
}

/**
 * Check if wallet is connected
 * @returns {boolean}
 */
export function isConnected() {
  if (TEST_MODE && testAccount) {
    return true  // Always connected in test mode
  }
  return modal.getIsConnectedState()
}

/**
 * Open the wallet connection modal
 */
export async function openModal() {
  if (TEST_MODE) {
    console.log('TEST MODE: Skipping wallet modal, using test account:', testAccount?.address)
    return
  }
  await modal.open()
}

/**
 * Get the wallet provider for signing
 * @returns {Promise<any>} The wallet provider
 */
export async function getProvider() {
  const provider = modal.getWalletProvider()
  if (!provider) {
    throw new Error('No wallet provider available')
  }
  return provider
}

/**
 * Create a ClientEvmSigner that wraps the browser wallet provider
 * This adapter converts the wallet provider's eth_signTypedData_v4 method
 * to the interface expected by @x402/evm
 */
async function createWalletSigner() {
  const address = getAddress()
  if (!address) {
    throw new Error('No wallet connected')
  }

  const provider = await getProvider()

  return {
    address: checksumAddress(address),
    async signTypedData({ domain, types, primaryType, message }) {
      console.log('[x402] Signing typed data with wallet provider')
      console.log('[x402] Domain:', domain)
      console.log('[x402] Message:', message)

      // Prepare typed data for eth_signTypedData_v4
      // Convert BigInts to strings for JSON serialization
      const serializableMessage = {}
      for (const [key, value] of Object.entries(message)) {
        if (typeof value === 'bigint') {
          // Use decimal strings for uint256 values
          serializableMessage[key] = value.toString()
        } else {
          serializableMessage[key] = value
        }
      }

      const typedData = {
        domain,
        types: {
          // EIP712Domain is typically auto-generated by wallets, but include it for safety
          EIP712Domain: [
            { name: 'name', type: 'string' },
            { name: 'version', type: 'string' },
            { name: 'chainId', type: 'uint256' },
            { name: 'verifyingContract', type: 'address' }
          ],
          ...types
        },
        primaryType,
        message: serializableMessage
      }

      console.log('[x402] Serialized typed data:', JSON.stringify(typedData, null, 2))

      const signature = await provider.request({
        method: 'eth_signTypedData_v4',
        params: [address, JSON.stringify(typedData)]
      })

      console.log('[x402] Signature obtained:', signature.slice(0, 20) + '...')
      return signature
    }
  }
}

/**
 * Create an x402 fetch client with wallet signer
 */
async function createX402Fetch() {
  let signer

  if (TEST_MODE && testAccount) {
    console.log('[x402] Using test account as signer')
    signer = testAccount
  } else {
    console.log('[x402] Creating wallet signer')
    signer = await createWalletSigner()
  }

  const client = new x402Client()
  registerExactEvmScheme(client, { signer })

  return wrapFetchWithPayment(fetch, client)
}

/**
 * Fetch wrapper that handles x402 payments automatically using the official @x402/fetch library
 * @param {string} url - The URL to fetch
 * @param {object} options - Fetch options
 * @returns {Promise<Response>}
 */
export async function fetchWithPayment(url, options = {}) {
  console.log('%c[x402] üì° fetchWithPayment', 'color: #6366f1; font-weight: bold')
  console.log('[x402] URL:', url)
  console.log('[x402] Method:', options.method || 'GET')

  if (options.body) {
    try {
      console.log('[x402] Body:', JSON.parse(options.body))
    } catch {
      console.log('[x402] Body:', options.body)
    }
  }

  // Check if wallet is connected (for non-test mode)
  if (!TEST_MODE && !isConnected()) {
    console.log('[x402] Wallet not connected, opening modal...')
    await openModal()
    // Wait for connection
    await new Promise((resolve, reject) => {
      const checkConnection = setInterval(() => {
        if (isConnected()) {
          clearInterval(checkConnection)
          resolve()
        }
      }, 500)
      // Timeout after 60 seconds
      setTimeout(() => {
        clearInterval(checkConnection)
        reject(new Error('Wallet connection timeout'))
      }, 60000)
    })
  }

  try {
    // Create x402-wrapped fetch
    const x402Fetch = await createX402Fetch()

    // Make the request - x402 library handles 402 responses automatically
    const response = await x402Fetch(url, options)

    console.log('[x402] Response status:', response.status, response.statusText)

    if (response.ok) {
      console.log('%c[x402] ‚úÖ Request successful', 'color: #10b981; font-weight: bold')

      // Check for payment response header
      const paymentResponseHeader = response.headers.get('PAYMENT-RESPONSE')
      if (paymentResponseHeader) {
        try {
          const settlementResult = JSON.parse(atob(paymentResponseHeader))
          if (settlementResult?.success && settlementResult?.transaction) {
            console.log('%c[x402] ‚úÖ Payment settled on-chain!', 'color: #10b981; font-weight: bold; font-size: 14px')
            const explorerUrl = `https://basescan.org/tx/${settlementResult.transaction}`
            console.log('[x402] üîó View on BaseScan:', explorerUrl)
          }
        } catch (e) {
          // Ignore parse errors
        }
      }
    } else {
      console.error('%c[x402] ‚ùå Request failed', 'color: #ef4444; font-weight: bold')
      console.error('[x402] Status:', response.status)

      // Log error details
      const errorHeader = response.headers.get('PAYMENT-REQUIRED')
      if (errorHeader) {
        try {
          const errorData = JSON.parse(atob(errorHeader))
          console.error('[x402] Error:', errorData.error || errorData)
        } catch (e) {
          // Ignore parse errors
        }
      }
    }

    return response
  } catch (error) {
    console.error('%c[x402] ‚ùå Fetch error', 'color: #ef4444; font-weight: bold')
    console.error('[x402] Error:', error)
    throw error
  }
}

// Export modal for direct access if needed
export { modal, wagmiAdapter }
